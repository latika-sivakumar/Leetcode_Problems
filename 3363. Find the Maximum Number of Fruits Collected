# This function calculates the maximum number of fruits that can be collected in a square grid.
# The grid has fruits in each cell, and we collect fruits along three paths:
# 1. Diagonal from top-left to bottom-right (always taken)
# 2. Right path from top-left to bottom-right corner moving only down and right
# 3. Bottom path from top-left to bottom-right corner moving only right and down
# The right and bottom paths are mirror directions and are computed simultaneously.
# Dynamic programming (with sliding window optimization) is used to track max fruits collected at each distance from diagonal.
# The window size adjusts as the paths converge towards the middle and diverge from it.

# Time Complexity: O(n^2)
# - Outer loop runs (n - 2) times
# - Inner loop (distance) runs at most O(n)
# - Each iteration does constant time work

# Space Complexity: O(n)
# - Only two DP arrays of size at most O(n) are maintained (right_path and bottom_path)

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        total = sum(fruits[i][i] for i in range(n))
        right_path = [0] * 3
        right_path[0] = fruits[0][n - 1]
        bottom_path = [0] * 3
        bottom_path[0] = fruits[n - 1][0]
        window = 2
        for step in range(1, n - 1):
            new_right = [0] * (window + 2)
            new_bottom = [0] * (window + 2)
            for dist in range(window):
                left = right_path[dist - 1] if dist - 1 >= 0 else 0
                mid = right_path[dist]
                right = right_path[dist + 1] if dist + 1 < len(right_path) else 0
                new_right[dist] = max(left, mid, right) + fruits[step][n - 1 - dist]
                left = bottom_path[dist - 1] if dist - 1 >= 0 else 0
                mid = bottom_path[dist]
                right = bottom_path[dist + 1] if dist + 1 < len(bottom_path) else 0
                new_bottom[dist] = max(left, mid, right) + fruits[n - 1 - dist][step]
            right_path = new_right
            bottom_path = new_bottom
            if window - n + 4 + step <= 1:
                window += 1
            elif window - n + 3 + step > 1:
                window -= 1
        return total + right_path[0] + bottom_path[0]
