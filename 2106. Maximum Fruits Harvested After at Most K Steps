# - The goal is to collect the maximum total number of fruits starting from `startPos` within `k` steps.
# - Use a sliding window approach over the sorted list of fruit positions.
# - Maintain a prefix sum array to quickly calculate total fruits within any window.
# - For each right bound, expand the window and compute the cost of visiting all positions between left and right.
#   The cost is: (right - left) + min(start-to-left, start-to-right), since you go to one end and walk straight.
# - If cost exceeds `k`, shrink the window from the left.
# - Track the maximum number of fruits collected across all valid windows.

# Time Complexity: O(n), where n is the number of fruit positions (since left and right pointers each move at most n times).
# Space Complexity: O(n), for prefix sum and position arrays.

import math
class Solution:
    def maxTotalFruits(self, fruits: list[list[int]], startPos: int, k: int) -> int:
        n = len(fruits)
        positions = [fruit[0] for fruit in fruits]
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i+1] = prefix_sum[i] + fruits[i][1]
        max_fruits = 0
        left = 0
        for right in range(n):
            pos_l, pos_r = positions[left], positions[right]
            cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r))
            while left <= right and cost > k:
                left += 1
                if left > right:
                    break
                pos_l, pos_r = positions[left], positions[right]
                cost = (pos_r - pos_l) + min(abs(startPos - pos_l), abs(startPos - pos_r))
            if left <= right:
                current_fruits = prefix_sum[right + 1] - prefix_sum[left]
                max_fruits = max(max_fruits, current_fruits)
        return max_fruits
